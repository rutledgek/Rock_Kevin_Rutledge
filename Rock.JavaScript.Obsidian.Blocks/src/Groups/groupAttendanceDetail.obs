<template>
    <Alert v-if="config.isNotAuthorizedError" alertType="danger">
        <strong>Sorry</strong>
        <p>You're not authorized to update the attendance for the selected group.</p>
    </Alert>
    <Alert v-if="config.isNoAttendanceOccurrencesError" alertType="danger">
        <strong>No Occurrences</strong>
        <p>There are currently not any active occurrences for selected group for which to take attendance.</p>
    </Alert>
    <Alert v-if="config.isGroupNotFoundError" alertType="danger">
        <strong>No Group</strong>
        Group was not found.
    </Alert>
    <Alert v-if="config.errorMessage" alertType="danger">
        <strong>Sorry</strong>
        <p>{{ config.errorMessage }}</p>
    </Alert>
    <div v-if="!config.isConfigError">
        <Panel :title="panelTitle">
            <template #headerActions>
                <div class="mr-2">
                    <CampusFilter v-model="campusFilter" v-model:campusGuid="campusGuid" />
                </div>
            </template>

            <template #default>
                <Alert v-if="errorMessage" alertType="danger">{{ errorMessage }}</Alert>

                <div class="row">
                    <div class="col-sm-4">
                        <DatePicker
                            v-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.DatePicker"
                            v-model="attendanceForDate"
                            :displayCurrentOption="false"
                            :isCurrentDateOffset="false"
                            :disableForceParse="false"
                            :disableShowOnFocus="false"
                            :disableHighlightToday="false"
                            :disallowFutureDateSelection="config.isFutureOccurrenceDateSelectionRestricted"
                            :disallowPastDateSelection="false"
                            label="Attendance For"
                        />
                        <div v-else-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.Specific">
                            <RockLabel>Attendance For</RockLabel>
                            <div>{{ attendanceForDate }}</div>
                        </div>
                        <!--
                            if (attendanceDateSelectionMode === AttendanceForMode.PickFromSchedule
                                ||
                                (
                                    groupLocationConfigHasSchedule
                                    &&
                                    (
                                        attendanceDateSelectionMode === AttendanceForMode.CurrentDate
                                        ||
                                        location.queryString["date"]
                                    )
                                )) {
                                //  then present the schedule options that match the block setting constraints.
                            }
                        -->
                        <AttendanceOccurrencePicker
                            v-else-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.ScheduledDatePicker"
                            Label="Attendance For"
                            rules="required" />
                    </div>

                    <div class="col-sm-4">
                        <GroupLocationPicker
                            v-if="config.locationSelectionMode === GroupAttendanceDetailLocationSelectionMode.GroupLocationPicker"
                            :groupGuid="config.groupGuid"
                            label="Location"
                            :showBlankItem="true"
                            @update:modelValue="onGroupLocationPickerChanged" />
                        <div v-else-if="config.locationSelectionMode === GroupAttendanceDetailLocationSelectionMode.Specific">
                            <RockLabel>Location</RockLabel>
                            <div>{{ config.locationLabel }}</div>
                        </div>
                    </div>

                    <div class="col-sm-4">
                        <GroupLocationSchedulePicker
                            v-if="config.scheduleSelectionMode === GroupAttendanceDetailScheduleSelectionMode.GroupLocationSchedulePicker"
                            @update:modelValue="onGroupLocationSchedulePickerChanged"
                            :groupGuid="config.groupGuid"
                            label="Schedule"
                            :locationGuid="locationGuid"
                            :showBlankItem="true"
                            />
                        <div v-else-if="config.scheduleSelectionMode === GroupAttendanceDetailScheduleSelectionMode.Specific">
                            <RockLabel>Schedule</RockLabel>
                            <div>{{ config.scheduleLabel }}</div>
                        </div>
                    </div>
                </div>

                <TransitionVerticalCollapse speed="fast">
                    <div v-show="attendanceOccurrenceGuid">
                        <div class="row">
                            <div class="col-sm-3">
                                <InlineCheckBox
                                    :modelValue="didNotOccur"
                                    :disabled="isSavingDidNotOccur"
                                    label="We Did Not Meet"
                                    @update:modelValue="onDidNotOccurChanged" />
                            </div>

                            <div class="col-sm-3">
                                <RadioButtonList
                                    v-if="config.attendanceOccurrenceTypes && config.isAttendanceOccurrenceTypesSectionShown"
                                    :modelValue="attendanceOccurrenceType"
                                    :label="config.attendanceOccurrenceTypesSectionLabel"
                                    :horizontal="true"
                                    :items="config.attendanceOccurrenceTypes"
                                    @update:modelValue="onAttendanceOccurrenceTypeChanged" />
                            </div>

                            <div class="col-sm-3">
                                <PersonPicker @update:modelValue="onAddPerson($event)"></PersonPicker>
                            </div>

                            <div class="col-sm-3">
                                <RockButton v-if="config.addGroupMemberPageUrl" btnType="default" @click="onAddGroupMemberClicked"><i class="fa fa-plus"></i> Add Group Member</RockButton>
                            </div>
                        </div>

                        <TransitionVerticalCollapse speed="fast">
                            <div v-show="!didNotOccur">
                                <div class="row">
                                    <div class="col-sm-4">
                                        <SearchFilter v-model="searchFilter" />
                                    </div>
                                </div>

                                <div class="row">
                                    <div class="col-sm-12">
                                        <RosterFilterPicker
                                            v-model="rosterFilter"
                                            class="mt-3"
                                            :attendances="attendances"
                                            :isFilterByFirstNameInitial="sortBy === SortType.FirstNameFirst"
                                            :isMultiselect="true">
                                        </RosterFilterPicker>
                                    </div>
                                </div>

                                <div class="row">
                                    <div class="col-sm-12">
                                        <AttendanceRoster
                                            :attendances="attendances"
                                            :filterBy="attendanceFilterByDelegate"
                                            :groupBy="attendanceGroupByDelegate"
                                            :groupWhenFilteredAttendanceCountExceeds="50"
                                            :sortBy="attendanceSortByDelegate"
                                            @attendanceChanged="onAttendanceChanged($event)" />
                                    </div>
                                </div>
                            </div>
                        </TransitionVerticalCollapse>

                        <div class="row">
                            <div class="col-sm-12">
                                <TextBox
                                    v-model="notes"
                                    label="Notes"
                                    :rows="3"
                                    textMode="multiline" />
                            </div>
                        </div>


                        <Alert v-if="!isPrintingRoster && printRosterWarning" alertType="warning">{{ printRosterWarning }}</Alert>

                        <div class="actions">
                            <RockButton tooltip="Print Attendance Roster" CssClass="btn btn-default btn-sm btn-square pull-right" @click="onPrintAttendanceRosterClicked()"><i class="fa fa-print"></i></RockButton>
                        </div>

                        <RockButton @click="onSaveClicked()">Save</RockButton>
                    </div>
                </TransitionVerticalCollapse>
            </template>
        </Panel>
    </div>
</template>

<script setup lang="ts">
    import { computed, ref, watch } from "vue";
    import AttendanceOccurrencePicker from "./GroupAttendanceDetail/attendanceOccurrencePicker.partial.obs";
    import CampusFilter from "./GroupAttendanceDetail/campusFilter.partial.obs";
    import AttendanceRoster from "./GroupAttendanceDetail/attendanceRoster.partial.obs";
    import GroupLocationPicker from "./GroupAttendanceDetail/groupLocationPicker.partial.obs";
    import GroupLocationSchedulePicker from "./GroupAttendanceDetail/groupLocationSchedulePicker.partial.obs";
    import SearchFilter from "./GroupAttendanceDetail/searchFilter.partial.obs";
    import { AttendanceSortByDelegate, byFirstName, byLastName, createSortBy, SortType } from "./GroupAttendanceDetail/attendanceSortByDelegate";
    import RosterFilterPicker from "./GroupAttendanceDetail/attendanceFilter.partial.obs";
    import { createEveryFilter as every, IRosterFilter, NoFilter } from "./GroupAttendanceDetail/filterType";
    import { AttendanceGroupByDelegate } from "./GroupAttendanceDetail/attendanceGroupByDelegate";
    import Alert from "@Obsidian/Controls/alert.obs";
    import DatePicker from "@Obsidian/Controls/datePicker.obs";
    import InlineCheckBox from "@Obsidian/Controls/inlineCheckBox";
    import Panel from "@Obsidian/Controls/panel";
    import PersonPicker from "@Obsidian/Controls/personPicker";
    import RadioButtonList from "@Obsidian/Controls/radioButtonList";
    import RockButton from "@Obsidian/Controls/rockButton";
    import RockLabel from "@Obsidian/Controls/rockLabel";
    import TextBox from "@Obsidian/Controls/textBox";
    import TransitionVerticalCollapse from "@Obsidian/Controls/transitionVerticalCollapse";
    import { GroupAttendanceDetailDateSelectionMode } from "@Obsidian/Enums/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailDateSelectionMode";
    import { GroupAttendanceDetailLocationSelectionMode } from "@Obsidian/Enums/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailLocationSelectionMode";
    import { GroupAttendanceDetailScheduleSelectionMode } from "@Obsidian/Enums/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailScheduleSelectionMode";
    import { Guid } from "@Obsidian/Types";
    import { HttpResult } from "@Obsidian/Types/Utility/http";
    import { onConfigurationValuesChanged, useConfigurationValues, useInvokeBlockAction, useReloadBlock } from "@Obsidian/Utility/block";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { GroupAttendanceDetailInitializationBox } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailInitializationBox";
    import { GroupAttendanceDetailPrintRosterResponseBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailPrintRosterResponseBag";
    import { GroupAttendanceDetailMarkAttendanceRequestBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailMarkAttendanceRequestBag";
    import { GroupAttendanceDetailUpdateDidNotOccurRequestBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailUpdateDidNotOccurRequestBag";
    import { GroupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag";
    import { GroupAttendanceDetailAttendanceBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailAttendanceBag";
    import { GroupAttendanceDetailSaveAttendanceOccurrenceRequestBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailSaveAttendanceOccurrenceRequestBag";
    import { GroupAttendanceDetailSaveAttendanceOccurrenceResponseBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailSaveAttendanceOccurrenceResponseBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { AttendanceUpdatedMessageBag } from "@Obsidian/ViewModels/Event/attendanceUpdatedMessageBag";
    import { AttendanceStatus } from "@Obsidian/Enums/Event/attendanceStatus";
    import { getTopic, ITopic, ServerFunctions } from "@Obsidian/Utility/realTime";
    import { AttendanceFilterByDelegate } from "./GroupAttendanceDetail/attendanceFilterByDelegate";
    import { GroupAttendanceDetailGetAttendanceRequestBag } from "@Obsidian/ViewModels/Blocks/Groups/GroupAttendanceDetail/groupAttendanceDetailGetAttendanceRequestBag";
    import { createSwitch } from "./GroupAttendanceDetail/switch";

    // TODO JMH This config should contain the group GUID for use in the specific group controls.
    const config = ref(useConfigurationValues<GroupAttendanceDetailInitializationBox>());
    const invokeBlockAction = useInvokeBlockAction();

    type NullableListItemBags = ListItemBag | ListItemBag[] | null;

    type GroupAttendanceTopic = ITopic<ServerFunctions<unknown>> & {
        attendanceOccurrenceGuid: Guid,
        groupGuid: Guid
    };

    const autoMarkAttendanceSwitch = createSwitch();
    const autoMarkAttendance = autoMarkAttendanceSwitch.connectToFunc(markAttendance);

    const autoSaveDidNotOccurSwitch = createSwitch();
    const autoUpdateDidNotOccur = autoSaveDidNotOccurSwitch.connectToFunc(updateDidNotOccur);

    const autoSaveAttendanceOccurrenceTypeSwitch = createSwitch();
    const autoUpdateAttendanceOccurrenceType = autoSaveAttendanceOccurrenceTypeSwitch.connectToFunc(updateAttendanceOccurrenceType);

    //#region Values

    const dateFormat = computed(() => config.value.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.DatePicker ? "yyyy-MM-dd" : "MM/dd/yyyy");
    const isPrintingRoster = ref<boolean>(false);
    const printRosterWarning = ref<string>("");
    const errorMessage = ref<string>("");
    const searchFilter = ref<IRosterFilter>(NoFilter);
    const campusFilter = ref<IRosterFilter>(NoFilter);
    const rosterFilter = ref<IRosterFilter>(NoFilter);
    const attendanceOccurrenceGuid = ref<string | null | undefined>(config.value.attendanceOccurrenceGuid);
    const attendanceForDate = ref<string>(
        (config.value.attendanceOccurrenceDate && RockDateTime.parseISO(config.value.attendanceOccurrenceDate)?.toASPString(dateFormat.value))
            || RockDateTime.now().toASPString(dateFormat.value));
    const attendanceOccurrenceType = ref<Guid | undefined>(config.value.selectedAttendanceOccurrenceTypeValue ?? undefined);
    const locationGuid = ref<Guid | undefined | null>(config.value.locationGuid);
    const scheduleGuid = ref<Guid | undefined | null>(config.value.scheduleGuid);
    const didNotOccur = ref<boolean>(config.value.isDidNotMeetChecked);
    const isSavingDidNotOccur = ref<boolean>(false);
    const campusGuid = ref<string | null | undefined>(config.value.campusGuid);
    const notes = ref<string>(config.value.notes ?? "");
    const topic = ref<GroupAttendanceTopic | null>();

    //#endregion

    //#region Computed Values

    const panelTitle = computed(() => config.value.groupName ? `${config.value.groupName} Attendance` : "Group Attendance");
    const attendances = computed<GroupAttendanceDetailAttendanceBag[]>(() => config.value?.roster ?? []);
    const sortBy = computed<SortType>(() => config.value.areAttendeesSortedByFirstName ? SortType.FirstNameFirst : SortType.LastNameFirst);
    const attendanceSortByDelegate = computed<AttendanceSortByDelegate>(() =>
        sortBy.value === SortType.FirstNameFirst
            ? createSortBy(byFirstName, byLastName)
            : createSortBy(byLastName, byFirstName));
    const attendanceFilterByDelegate = computed<AttendanceFilterByDelegate>(() => (attendance) => every(campusFilter.value, searchFilter.value, rosterFilter.value).filter(attendance));
    const attendanceGroupByDelegate = computed<AttendanceGroupByDelegate | null>(() => {
        if (sortBy.value === SortType.FirstNameFirst) {
            return (attendance: GroupAttendanceDetailAttendanceBag) => attendance.nickName?.charAt(0) || "?";
        }
        else {
            return (attendance: GroupAttendanceDetailAttendanceBag) => attendance.lastName?.charAt(0) || "?";
        }
    });

    //#endregion

    //#region Event Handlers

    function onAddPerson(personId: number): void {
        // TODO JMH Implement this.
        console.log(personId);
    }

    function onAddGroupMemberClicked(): void {
        if (config.value.addGroupMemberPageUrl) {
            location.href = config.value.addGroupMemberPageUrl;
        }
    }

    async function onAttendanceChanged(attendance: GroupAttendanceDetailAttendanceBag): Promise<void> {
        await autoMarkAttendance({
            attendanceOccurrenceGuid: attendanceOccurrenceGuid.value,
            personGuid: attendance.personGuid,
            didAttend: attendance.didAttend
        });
    }

    async function onAttendanceOccurrenceTypeChanged(newAttendanceOccurrenceType: Guid): Promise<void> {
        await autoUpdateAttendanceOccurrenceType({
            attendanceOccurrenceGuid: attendanceOccurrenceGuid.value,
            attendanceOccurrenceTypeGuid: newAttendanceOccurrenceType
        });
    }

    async function onDidNotOccurChanged(newDidNotOccur: boolean): Promise<void> {
        await autoUpdateDidNotOccur({
            attendanceOccurrenceGuid: attendanceOccurrenceGuid.value,
            didNotOccur: newDidNotOccur
        });
    }

    function onGroupLocationPickerChanged(locationPickerSelection: NullableListItemBags): void {
        locationGuid.value = (locationPickerSelection as ListItemBag)?.value;
    }

    function onGroupLocationSchedulePickerChanged(schedulePickerSelection: NullableListItemBags): void {
        scheduleGuid.value = (schedulePickerSelection as ListItemBag)?.value;
    }

    async function onPrintAttendanceRosterClicked(): Promise<void> {
        await printAttendanceRoster();
    }

    async function onSaveClicked(): Promise<void> {
        await save();
    }

    /**
     * Event handler for attendance update being received from the server in real-time.
     */
    function onAttendanceUpdatedFromServer(bag: AttendanceUpdatedMessageBag): void {
        if (bag.occurrenceGuid !== attendanceOccurrenceGuid.value) {
            // Ignore if not for this occurrence.
            return;
        }

        const attendance = attendances.value.find(attendance => attendance.personGuid === bag.personGuid);

        if (attendance) {
            attendance.didAttend = bag.status === AttendanceStatus.DidAttend;
        }
        else {
            // Attendance was added outside of this browser so add it here (it could have been added by an individual on another device).
            invokeBlockAction<GroupAttendanceDetailAttendanceBag>("GetAttendance", {
                attendanceGuid: bag.attendanceGuid
            })
            .then(result => result?.data)
            .then((attendance: GroupAttendanceDetailAttendanceBag | null) => {
                if (!attendance) {
                    return;
                }

                // Check if the Attendance record was already added once more before adding it.
                const existingAttendance = attendances.value.find(a => a.personGuid === attendance.personGuid);

                if (existingAttendance) {
                    attendance.didAttend = existingAttendance.didAttend;
                }
                else {
                    config.value.roster = [...config.value.roster ?? [], attendance];
                }
            });
        }
    }

    //#endregion

    //#region Functions

    /**
     * Subscribes to the real-time GroupAttendanceTopic and returns it.
     */
    async function getGroupAttendanceTopic(groupGuid: Guid, attendanceOccurrenceGuid: Guid): Promise<GroupAttendanceTopic> {
        const topic = await getTopic("Rock.RealTime.Topics.EntityUpdatedTopic");

        await invokeBlockAction("SubscribeToRealTime", { connectionId: topic.connectionId, groupGuid });

        // Associate the AttendanceOccurrence and Group unique identifiers to the topic so we don't have to keep passing them around.
        Object.defineProperty(topic, "attendanceOccurrenceGuid", {
            value: attendanceOccurrenceGuid,
            writable: false
        });

        Object.defineProperty(topic, "groupGuid", {
            value: groupGuid,
            writable: false
        });

        return topic as GroupAttendanceTopic;
    }

    /**
     * Gets or creates the AttendanceOccurrence based on the currently selected date, location, and schedule.
     */
    async function getOrCreateAttendanceOccurrence(): Promise<void> {
        const bag: GroupAttendanceDetailSaveAttendanceOccurrenceRequestBag = {
            didNotOccur: didNotOccur.value,
            attendanceOccurrenceDate: attendanceForDate.value,
            attendanceTypeGuid: attendanceOccurrenceType.value,
            attendees: attendances.value,
            campusGuid: campusGuid.value,
            locationGuid: locationGuid.value,
            notes: notes.value,
            scheduleGuid: scheduleGuid.value,
            areAttendeesSortedByFirstName: sortBy.value === SortType.FirstNameFirst,
            attendanceOccurrenceGuid: attendanceOccurrenceGuid.value
        };

        console.log("2. in getOrCreateAttendanceOccurrence");

        // Clear the error before calling get/create.
        errorMessage.value = "";

        const response = await invokeBlockAction<GroupAttendanceDetailInitializationBox>("GetOrCreate", { bag });

        if (response?.data) {
            config.value = response.data;
            console.log("3. config.value updated");
        }
        else if (config) {
            config.value.errorMessage = response?.errorMessage || "An unexpected error occurred.";
            console.log("3. config.value error");
        }
    }

    /**
     * Updates the DidAttend value of a single Attendance.
     */
    async function markAttendance(bag: GroupAttendanceDetailMarkAttendanceRequestBag): Promise<void> {
        await invokeBlockAction("MarkAttendance", { bag });
    }

    /**
     * Prints the Attendance roster.
     */
    async function printAttendanceRoster(): Promise<void> {
        try {
            isPrintingRoster.value = true;

            var result = await invokeBlockAction<GroupAttendanceDetailPrintRosterResponseBag>("PrintRoster");

            if (result?.errorMessage) {
                printRosterWarning.value = result.errorMessage;
            }
            else if (result?.data?.redirectUrl) {
                window.location.href = result.data.redirectUrl;
            }
        }
        finally {
            isPrintingRoster.value = false;
        }
    }

    /**
     * Saves the entire AttendanceOccurrence and Attendance records.
     */
    async function save(): Promise<HttpResult<GroupAttendanceDetailSaveAttendanceOccurrenceResponseBag>> {
        const bag: GroupAttendanceDetailSaveAttendanceOccurrenceRequestBag = {
            didNotOccur: didNotOccur.value,
            attendanceOccurrenceDate: attendanceForDate.value,
            attendanceTypeGuid: attendanceOccurrenceType.value,
            attendees: attendances.value,
            campusGuid: campusGuid.value,
            locationGuid: locationGuid.value,
            notes: notes.value,
            scheduleGuid: scheduleGuid.value,
            areAttendeesSortedByFirstName: sortBy.value === SortType.FirstNameFirst,
            attendanceOccurrenceGuid: attendanceOccurrenceGuid.value
        };

        // Clear the error before saving.
        errorMessage.value = "";

        const response = await invokeBlockAction<GroupAttendanceDetailSaveAttendanceOccurrenceResponseBag>("SaveAttendanceOccurrence", { bag });

        if (response?.data?.redirectUrl) {
            attendanceOccurrenceGuid.value = response.data.attendanceOccurrenceGuid;
        }
        else {
            errorMessage.value = response.errorMessage || "An unexpected error occurred. Please try again.";
        }

        return response;
    }

    /**
     * Updates the type of the current AttendanceOccurrence.
     */
    async function updateAttendanceOccurrenceType(bag: GroupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag): Promise<void> {
        await invokeBlockAction("UpdateAttendanceOccurrenceType", { bag });
    }

    /**
     * Unsubscribes from real-time updates to the Group Attendance Occurrence.
     */
    async function unsubscribeFromRealTime(bag: { connectionId: string | null, groupGuid: Guid }): Promise<void> {
        await invokeBlockAction("UnsubscribeFromRealTime", { connectionId: bag.connectionId, groupGuid: bag.groupGuid });
    }

    /**
     * Updates the AttendanceOccurrence DidNotOccur value.
     */
    async function updateDidNotOccur(bag: GroupAttendanceDetailUpdateDidNotOccurRequestBag): Promise<void> {
        if (isSavingDidNotOccur.value) {
            // Skip if "did not occur" is already being saved.
            return;
        }

        const wasSwitchOn = autoMarkAttendanceSwitch.isOn;

        if (bag.didNotOccur) {
            // If the occurrence did not happen, then stop auto-saving attendances before we auto-save "did occur".
            if (wasSwitchOn) {
                autoMarkAttendanceSwitch.turnOff();
            }

            // Update client state to match the server before saving.
            didNotOccur.value = bag.didNotOccur;
        }

        try {
            isSavingDidNotOccur.value = true;

            await invokeBlockAction<void>("UpdateDidNotOccur", { bag });
        }
        finally {
            isSavingDidNotOccur.value = false;
        }

        if (!bag.didNotOccur) {
            // Update client state to match the server after saving.
            didNotOccur.value = bag.didNotOccur;

            // If the occurrence did happen, then start auto-saving attendances after "did occur" is auto-saved.
            if (wasSwitchOn) {
                autoMarkAttendanceSwitch.turnOn();
            }
        }
    }

    /**
     * Subscribes to the topic using the current Group and AttendanceOccurrence unique identifiers.
     */
    async function startRealTime(): Promise<GroupAttendanceTopic> {
        const groupGuid = config.value.groupGuid;
        const occurrenceGuid = attendanceOccurrenceGuid.value;

        console.log("startRealTime(): 1. starting");

        if (topic.value && topic.value.groupGuid === groupGuid && topic.value.attendanceOccurrenceGuid === occurrenceGuid) {
            // Skip if already subscribed.
            console.log("startRealTime(): 2. skipping");
            return topic.value;
        }

        // Unsubscribe from the current topic before starting real-time.
        await stopRealTime();

        if (!attendanceOccurrenceGuid.value || !config.value.groupGuid) {
            console.log("startRealTime(): 4. unable to start");
            throw "Unable to start real-time";
        }
        console.log("startRealTime(): 4. getting topic");

        const groupAttendanceTopic = await getGroupAttendanceTopic(config.value.groupGuid, attendanceOccurrenceGuid.value);

        console.log("startRealTime(): 5. got topic");
        groupAttendanceTopic.onDisconnected(async () => {
            startRealTime();
        });

        groupAttendanceTopic.on("attendanceUpdated", onAttendanceUpdatedFromServer);

        // Extra logic that needs to happen on every connection goes here.

        // if (!isReconnecting) {
        //     // One time logic goes here.
        // }
        console.log("startRealTime(): 6. done");

        return groupAttendanceTopic;
    }

    /**
     * Unsubscribes from the current topic if subscribed.
     */
    async function stopRealTime(): Promise<void> {
        console.log("startRealTime(): 2. stopping existing");

        if (!topic.value) {
            console.log("startRealTime(): 3. stopped non-existing");
            return;
        }

        await unsubscribeFromRealTime({ connectionId: topic.value.connectionId, groupGuid: topic.value.groupGuid });
        console.log("startRealTime(): 3. stopped existing");
    }

    /**
     * Turns off auto-save functionality by turning off all auto-save switches.
     */
    function turnOffAutoSave(): void {
        autoMarkAttendanceSwitch.turnOff();
        autoSaveDidNotOccurSwitch.turnOff();
        autoSaveAttendanceOccurrenceTypeSwitch.turnOff();
    }

    /**
     * Turns on auto-save functionality by turning on all auto-save switches.
     */
    function turnOnAutoSave(): void {
        autoMarkAttendanceSwitch.turnOn();
        autoSaveDidNotOccurSwitch.turnOn();
        autoSaveAttendanceOccurrenceTypeSwitch.turnOn();
    }

    //#endregion

    //#region Watchers

    /**
     * Keeps the reactive values up-to-date when the config changes.
     * Config changes occur when the AttendanceOccurrence changes.
     */
    watch(config, () => {
        console.log("4. refs updated from config");
        attendanceOccurrenceGuid.value = config.value.attendanceOccurrenceGuid;
        // attendanceForDate.value =
        //     (config.value.attendanceOccurrenceDate && RockDateTime.parseISO(config.value.attendanceOccurrenceDate)?.toASPString(dateFormat.value))
        //         || RockDateTime.now().toASPString(dateFormat.value);
        attendanceOccurrenceType.value = config.value.selectedAttendanceOccurrenceTypeValue ?? undefined;
        // locationGuid.value =  config.value.locationGuid;
        // scheduleGuid.value = config.value.scheduleGuid;
        didNotOccur.value =  config.value.isDidNotMeetChecked;
        campusGuid.value = config.value.campusGuid;
        notes.value = config.value.notes ?? "";
    });

    /**
     * Gets an existing or creates a new AttendanceOccurrence when the date, location, or schedule changes.
     */
    watch([attendanceForDate, locationGuid, scheduleGuid], async () => {
        console.log("1. in config reload watch");
        attendanceOccurrenceGuid.value = null;

        if (attendanceForDate.value && locationGuid.value && scheduleGuid.value) {
            await getOrCreateAttendanceOccurrence();
        }
    });

    /**
     *
     */
    watch([attendanceOccurrenceGuid], async () => {
        // Turn auto-save off whenever attendance occurrence is changed.
        console.log("5. auto-save was turned off.");

        turnOffAutoSave();

        if (attendanceOccurrenceGuid.value) {
            turnOnAutoSave();
            console.log("6. in watch startRealTime");
            await startRealTime();
            console.log("7. auto-save was turned back on.");
        }
        else {
            await stopRealTime();
        }
    });

    //#endregion

    // Auto-save can be disabled by disconnecting all auto-save switches.

    if (config.value.attendanceOccurrenceGuid) {
        console.log("0. in startup startRealTime");
        turnOnAutoSave();
        startRealTime();
    }

    onConfigurationValuesChanged(useReloadBlock());
</script>