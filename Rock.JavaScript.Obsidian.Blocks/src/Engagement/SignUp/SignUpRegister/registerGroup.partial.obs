<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Alert v-if="!identifiableGroupMembers.length" alertType="warning">
        No group members found to register for this project.
    </Alert>

    <div v-else>
        <h3 v-if="props.title">{{ props.title }}</h3>

        <div v-if="eligibleGroupMembers.length" class="mt-3">
            <CheckBoxList v-model="registeredGroupMembers"
                          label=""
                          :items="eligibleGroupMembers"
                          :disabled="isRegistering"
                          @update:modelValue="onRegisteredGroupMembersChanged" />
        </div>

        <div v-if="ineligibleGroupMembers.length" class="mt-3">
            <ListUnmetRequirements :registrants="ineligibleGroupMembers" />
        </div>
    </div>
</template>

<script setup lang="ts">
    import { computed, PropType } from "vue";
    import ListUnmetRequirements from "./listUnmetRequirements.partial.obs";
    import Alert from "@Obsidian/Controls/alert.obs";
    import CheckBoxList from "@Obsidian/Controls/checkBoxList";
    import { SignUpRegistrantBag } from "@Obsidian/ViewModels/Blocks/Engagement/SignUp/SignUpRegister/signUpRegistrantBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const props = defineProps({
        isRegistering: {
            type: Boolean as PropType<boolean>,
            required: true
        },

        registrants: {
            type: Array as PropType<SignUpRegistrantBag[]>,
            required: true
        },

        title: {
            type: String as PropType<string | null | undefined>,
            default: ""
        }
    });

    // #region Computed Values

    const identifiableGroupMembers = computed((): SignUpRegistrantBag[] => {
        return props.registrants
            ?.filter((r: SignUpRegistrantBag) =>
                r?.personIdKey
                && r?.fullName
            ) ?? [];
    });

    const eligibleGroupMembers = computed((): ListItemBag[] => {
        return identifiableGroupMembers.value
            .filter((r: SignUpRegistrantBag) => !r.unmetGroupRequirements?.length)
            .map((r: SignUpRegistrantBag) => ({
                value: r.personIdKey,
                text: r.fullName
            }));
    });

    const registeredGroupMembers = computed<string[]>({
        get() {
            return identifiableGroupMembers.value
                .filter((r: SignUpRegistrantBag) => r.willAttend)
                // r.personIdKey will never be null | undefined here, but TS is only happy if we use the nullish coalescing operator.
                .map((r: SignUpRegistrantBag) => r.personIdKey ?? "");
        },
        set(newValue: string[]) {
            identifiableGroupMembers.value
                .forEach((r: SignUpRegistrantBag) => {
                    r.willAttend = newValue.some((personIdKey: string) => personIdKey === r.personIdKey);
                });
        }
    });

    const ineligibleGroupMembers = computed((): SignUpRegistrantBag[] => {
        return identifiableGroupMembers.value
            .filter((r: SignUpRegistrantBag) => r.unmetGroupRequirements?.length);
    });

    // #endregion

    // #region Event Handlers

    /**
     * Synchronizes each group member's `SignUpRegistrantBag.willAttend` value when the control emits changes.
     */
    function onRegisteredGroupMembersChanged(): void {
        props.registrants
            ?.filter((r: SignUpRegistrantBag) => r?.isRegistrar === false)
            .forEach((r: SignUpRegistrantBag) => {
                r.willAttend = registeredGroupMembers.value.some((personIdKey: string) => personIdKey === r.personIdKey);
            });
    }

    // #endregion
</script>